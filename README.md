# algorithm-project

算法设计Project：de Bruijn图上的编辑距离。

题目分为三个tasks，task1要求两个给定字符串的编辑距离；task2要求在k阶de Bruijn图上找到一条路径，其对应的字符串和给定字符串的编辑距离最小；task3是task2的数据范围放大版本。三个task都要输出具体方案。

题目具体描述和数据可以从[这里](http://datamining-iip.fudan.edu.cn/ppts/algo/pj2017/)拿到。

## Compile

```sh
g++ edit_distance1.cpp -o edit_distance1 -O2 -Wall
g++ edit_distance2.cpp -o edit_distance2 -O2 -Wall
g++ edit_distance3.cpp -o edit_distance3 -O3 -march=native -mtune=native -Wall -std=c++11 -g -mcmodel=large
```

其中`edit_distance3.cpp`的编译可以增加-fopenmp选项，不过由于种种原因(估计是线程同步需要等待时间)，使用openmp并没有能提高速度。可以考虑接下来将整个程序静态编译并加上`-pg`，然后用`gprof`看一下分析结果。

## Run

```
ulimit -s unlimited
time ./edit_distance3 < task3.in > task3.out
```

注意：`./edit_distance3`的运行需要较大的堆空间，实际运行大约60GB左右，整个程序运行时间在4h左右（常数优化前）。另外可以用`taskset`把进程绑到一个处理器上执行。

## Write-up

### task1

经典的levenshtein distance问题，求一个字符串A经过增加一个字符，删除一个字符，替换一个字符变成字符串B的代价。每个操作代价为1。

用f[i][j]表示将字符串A的前缀A[1..i]变成字符串B的前缀B[1..j]，最少需要多少次操作。

为了方便说明，令n = len(A), m = len(B)。f[0][i]和f[i][0]表示从空串变成另一个串的代价。

显然有f[i][0] = i; f[0][j] = j; 特殊的有f[0][0] = 0;

接下来为了计算f[i][j]，有最多四种可能的转移
```cpp
1. f[i][j] = f[i-1][j-1], A[i] == B[j]
2. f[i][j] = f[i-1][j] + 1
3. f[i][j] = f[i][j-1] + 1
4. f[i][j] = f[i-1][j-1] + 1
```

第一种转移表示能直接匹配，不需要额外代价，剩下三种转移分别表示删除A[i]，在A中增加字符B[j]，替换A[i]为B[j]。转移结束后f[n][m]就是最终答案。

为了输出方案，我们只需要记录转移的路径。另opt[i][j] = NOP/DEL/ADD/SUB，分别对应四种转移情况，在实际发生转移时，更新opt[i][j]为对应的值。这里要注意初始状态f[i][0] = i的转移可以看成是由f[i-1][0]转移而来，因此对应DEL转移，f[0][i]对应ADD转移。

有了opt[i][j]的值，就可以通过opt[n][m]往前倒推，每次根据当前是由上次那种转移过来，可以知道n,m的变化。同时可以知道当前在字符串A上做的操作是什么。这部分可以递归完成。当n+m == 0时，说明转移倒推到最开始了。因为答案不会超过字符串长度，因此递归深度不会特别大。

时间复杂度O(n^2)，空间复杂度O(n^2)，其中n为字符串最大长度。这个算法的空间可以继续优化，我们往下看

### task2

这个任务和task1任务不同。task2给出了一张图，图上每个节点是一个长度为k(k<=30)的字符串，两个节点之间存在有向边，当且仅当第一个字符串的长度为k-1的后缀，和第二个字符串长度为k-1的前缀完全相同。可以想象，图上一条长度为l的路径，构成了一个长度为k+l-1的字符串。现在给出字符串A，和m个长度为k的字符串，希望在图中找到一条路径，使得路径所对应的字符串和A的编辑距离最小。

首先说建图，这个过程没有什么难度，可以简单考虑用两个unordered_map<string, vector<int>>[2]表示有哪些编号的字符串以key为前缀或者后缀，具体来说M[0][prefix]表示以字符串prefix为前缀的字符串编号列表，M[1][suffix]表示以suffix为后缀的字符串编号列表。由于题目中约束字符集大小只有4，在实际数据中没有重复字符串出现的情况下，这个列表长度不会超过4。所以存图也可以用前向星，邻接表之类的方法存(这里用什么方法存图会在后面常数优化章节进行比较)。

在不考虑空间的情况下，这个题目仍然可以考虑用动态规划，因为可以发现在图上走一步，其实只增加了一个字符，这与第一问中字符串上走一步，本质是没有什么不同的。于是我们修改转移状态，用f[i][j][k]表示在字符串A的前缀A[1..i]，变化成一个在图上走了k步的字符串，这个字符串最后停在j这个节点上，最少需要多少代价。

考虑初始状态和转移，我们发现在这个dp过程中，转移每次增加一个字符，而初始状态是上来一个字符串作为开头，没法归类到转移当中。于是初始状态需要提出来单独计算。

对于初始状态，实际上我们需要计算f[i][j][1]，其中i和j是变值，即对每个字符串j，计算任意长度的前缀和变换到字符串j的代价。
这一部分我们可以调用task1中实现的函数，不做任何优化考虑，时间复杂度为O(n\*m\*k)，其中n为字符串A的长度，m为图中节点数，k为每个节点上字符串的长度。

接下来仍然考虑四种转移，为了方便起见，用tlen表示题目描述中的k，即节点上每个字符串的长度，用ns[j]表示第j个字符串
```cpp
1. f[i][j][k] = f[i-1][y][k-1], A[i] == ns[j][tlen]
2. f[i][j][k] = f[i-1][j][k-1] + 1
3. f[i][j][k] = f[i][y][k-1] + 1
4. f[i][j][k] = f[i-1][y][k-1] + 1
```

y表示字符串j的前一个可能的节点，转移的时候取较小值转移。类似的，第一种对应直接能匹配，第二种对应删除字符A[i]，第三种对应在A中增加字符ns[j][tlen]，第四种对应替换。

在这种情况下，答案等于这个数组中的最小值。但实际上我们并开不下空间存储这样的状态，于是考虑修改一下状态的含义。f[i][j][k]即路径不超过k的所有停在j上的字符串，变化到A的最小代价，相当于对前面的状态做一个继承。于是多一种转移f[i][j][k] = f[i][j][k-1]即可。这样我们可以发现f[i][j][k]一定是由f[x][y][k-1]转移而来，于是第三维可以滚动。

但实际上，仅仅是上面这样的考量是不够的。考虑这样一种情况，有三个字符串分别为"abb"，"bbc"，"bbb"，字符串2在和A的某个前缀比较时，可能从字符串1转移过来，也可能从字符串3转移过来，而不恰当的转移顺序会丢掉1先增加一个字符转移到3，再由3增加一个字符到2的情况。作为不，考虑转移顺序的一个workaround，考虑图中可能出现环的情况，对f[i][x][]最少需要重复转移tlen次，才能保证dp的正确性。

对于方案的输出，则需要多记录上一次是从哪个节点转移过来的，一样可以递归输出。

因此该算法的时间复杂度为O(n\*m\*k)，空间复杂度为O(n\*m), 对于task2的数据，可以在十几秒级别的时间出解。

### task3

面对task3的数据规模，我们主要解决task2算法时间和空间上的不足。

先考虑空间上的优化
1. task1当中的dp数组是可以滚动的，所以这里只需要O(m)的空间
2. task2中的dp数组，第一维也是可以滚动的，于是这里的空间也只有O(m)。
3. 对于方案的输出，由于一共有n\*m的状态，所以n\*m的空间必不可少，对于n=100000, m=1000000来说，n\*m个int需要大约400GB的内存空间，实际上，每种转移只有4种情况，对应2bit，而转移要记录上一个结点，又因为字符集大小只有4，且没有重复字符串，所以只关心上一个字符即可，也需要2bit，所以对于转移方案的记录，一个需要4bit，相比之前用int来存，我们节省了8倍的空间，于是这里空间大约需要50GB，在一台小型的服务器上已经可以承载。
4. 另外还有dp初始化需要记录结果，一共有n*m个结果需要保留，而实际上，由于数据随机，可以发现在ns[i]已经在A串中完全出现之后，其后面的值不需要再次计算。这里我们用m个vector，bound[i][j]表示第i个字符串，和A串的前缀A[1..j]的编辑距离，对于bound[i][j]+tlen==j之后的情况，可以不用存储。对于随机数据来说，在长度为100多的字符串中几乎就出现了ns[i]。所以这不但节省了空间，而且节省了dp初始化的计算时间。初始化时间和空间都降低为了O(m\*k\*k\*4)。

在空间优化完成后，程序就已经可以跑了，经过估计大约需要60h可以出解。然而时间上任然可以继续优化。
1. 观察task2中f[i][j][k]，已经对k这一维的转移结果进行继承了。为何不干脆把这一维直接优化掉？实践发现这样是可行的。于是记录状态的数组变成了f[i][j]
2. 实际上当一个状态f[i][j]在某次转移后值已经不变了，那么由它去再次转移后面的值没有意义。所以我们可以考虑用两个队列，每个队列里存放待转移的节点。第一个队列我们依次计算转移，当一个节点转移成功后，将其后继状态，也就是这个结点可以去更新的状态，加入到下一个队列中，等待下一轮转移。经过这个优化，结果发现从原来每个结点需要迭代tlen次，降低到了平均迭代2次左右。在这个优化加上之后，跑出结果大约只需要4h。

时间复杂度O(m\*k\*k\*4+n\*m\*4\*C)，空间复杂度O(n\*m)。这里的C最坏能达到k，但实际情况下C只有2左右。

### constant optimization

为了进一步优化，我们可以考虑从常数方面，和利于多线程并行方面进行。
1. 存图方面，因为需要大量次数的枚举图上相邻边，可以考虑用连续空间的存储代替前向星存储。
2. 考虑cpu cache，dp中的滚动数组应当将小的一维作为第二维。这样可以有效加快计算的速度。实测光是初始化阶段就快了几十倍。
3. 考虑用openmp来优化，这部分我做了一些工作，但效果不理想，我觉得主要有三个原因。
	1. 第一个原因是每个线程做的任务太少，反而线程之间来回取任务占用了更多时间，这个已经通过增大每个线程执行的工作量来解决了，但也只能是一个模糊的数值
	2. 第二个是线程之间同步，比如分出12个线程执行一个for循环，但for循环结束之后，需要等待所有线程都执行完，这里应该会花费不少时间
	3. 第三个是for虽然并行了，但访问内存速度是瓶颈，由于数据巨大，多线程得写内存范围伤害了cache的局部性，导致速率得不到提高。

## Others

感谢姜峻岩同学制作的数据，大大方便了我测试的过程
